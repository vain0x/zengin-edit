# 開発

## 技術スタック

- TypeScript, Node.js, Vite, Vue, Vuetify

## 開発環境

- Node.js

```sh
npm ci
```

## 開発用サーバー

```sh
npm run dev
```

## テスト

```sh
npm run test
```

## データ構造

### ドキュメントとレコード

ファイルに含まれるデータのことを **ドキュメント** (document) と呼ぶことにする。ドキュメントは **レコード** (record) と呼ばれる固定長データの並びである

```
    Document ::= {Record}
    Record ::= Header | Data | Trailer | End
```

レコードは **項目** (field) と呼ばれるデータ領域の並びである。レコードの先頭1バイトが **データ区分** (type) を表す。レコードの残りの部分の解釈はデータ区分によって異なる。データ区分ごとに、レコードを構成する項目が規定されている

項目は固定長である。数字のみの項目 (`N`) と、文字列の項目 (`C`) がある。使用可能な文字の種類には一定の制限がある (「付録1」を参照)

**改行**: なお、レコードフォーマットの仕様に書かれていないが、レコードの後に任意で改行コード (CRLF, LF または CR) を付与することもできる。改行は使用可能な文字に含まれていないので、項目内に有効なデータとして出現することはない

### データ表現

ドキュメントやレコードには3種類の表現を使う

- バイナリ表現 (`Uint8Array`)
    - 文字コードは JIS (※本来の仕様では JIS or EBCDIC だが EBCDIC は非対応とした)
- テキスト表現 (`string`)
- テーブル表現 (レコードは `string[]`, ドキュメントは `string[][]`)

### データ表現の変換

**バイナリ ⇔ テーブル**: レコードフォーマットの仕様にのっとって相互に変換できる

```
    document: bytes
    → records: bytes[] (レコード長や改行による分割)
    → array of fields: bytes[][] (項目のデータ長にもとづいて分割)
    → table: string[][] (文字コード変換)
```

```
    table: string[][]
    → array of fields: bytes[][] (データ長の補正、文字コード変換)
    → records: bytes[] (項目を連結)
    → document: bytes (レコードを連結)
```

入力データが不完全なケースも想定して変換時に補正を行う

- バイナリデータを解釈する際の補正
    - バイナリデータの最後に、1レコードの長さに満たないデータがある場合、末尾にスペースを埋めて1レコードとして処理する
    - バイナリデータの1レコード分のデータの途中に改行がある場合、その改行の直前までを1レコードとする (不足分はスペースで埋める)
- テーブルデータを解釈する際の補正
    - 項目のデータ長を固定値にする
        - 数値の項目は先頭をゼロで埋めるか、先頭部分を切り捨てる
        - 文字の項目は末尾をスペースで埋めるか、末尾を切り捨てる

**バイナリ ⇔ テキスト**: データ全体に文字コード変換を適用して相互に変換できる
